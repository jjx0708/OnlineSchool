{
  "code": 200,
  "data": "success",
  "eBook": "<div><p>希望你还记得，之前我们通过测试用例研究 Combine 事件发布订阅模型的时候，创建过一个叫做 <code>Publishers.Scan</code> 的对象对上游事件序列中的事件值进行累计。这一节，我们就通过自定义一个类似的<code>CustomScan</code>，来了解这类类型的工作原理。</p> <h2 id=\"toc_0\">自定义 CustomScan</h2> <p>同样作为一个 <code>Publisher</code>，其实实现的过程和上一节的 <code>CustomSubject</code> 是一样的。首先，根据它的订阅者接收事件的方式定义一个实现了 <code>SubscriptionBehavior</code> 的类型；其次，根据这个类型，实现 <code>Publisher</code> 约束的 <code>receive&lt;S&gt;(subscriber: S)</code> 就好了。</p> <p>为此，在项目中，我们创建了一个 CustomScan.swift，在其中添加 <code>CustomScan</code> 的实现。先来看 <code>CustomScan</code> 的定义：</p> <pre class=\"hljs\"><code class=\"swift hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomScan</span>&lt;<span class=\"hljs-title\">Upstream</span>: <span class=\"hljs-title\">Publisher</span>, <span class=\"hljs-title\">Output</span>&gt;: <span class=\"hljs-title\">Publisher</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Failure</span> = <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Failure</span>\n  <span class=\"hljs-keyword\">let</span> reducer: (<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Output</span>) -&gt; <span class=\"hljs-type\">Output</span>\n  <span class=\"hljs-keyword\">let</span> upstream: <span class=\"hljs-type\">Upstream</span>\n  <span class=\"hljs-keyword\">let</span> initialState: <span class=\"hljs-type\">Output</span>\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">init</span>(upstream: <span class=\"hljs-type\">Upstream</span>,\n    initialResult: <span class=\"hljs-type\">Output</span>,\n    nextPartialResult: @escaping (<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Output</span>) -&gt; <span class=\"hljs-type\">Output</span>) {\n    <span class=\"hljs-keyword\">self</span>.initialState = initialResult\n    <span class=\"hljs-keyword\">self</span>.reducer = nextPartialResult\n    <span class=\"hljs-keyword\">self</span>.upstream = upstream\n  }\n}\n</code></pre> <p>其中，泛型参数 <code>Upstream</code> 表示上游事件发布者的类型，<code>Output</code> 表示 <code>CustomScan</code> 自身转换出来的新事件类型。由于 <code>CustomScan</code> 不转换错误事件的类型，所以我们一开始，让 <code>Failure</code> 就是上游事件序列中的错误类型。接下来：</p> <ul><li><code>reducer</code> 是累计事件值的计算方法；</li> <li><code>upstream</code> 是上游事件序列的引用，由于 <code>CustomScan</code> 要依赖于上游事件进行计算，因此这个属性不是一个 optional；</li> <li><code>initialState</code> 是计算的初始值；</li></ul> <p>在 memberwise init 方法里，逐个对这些属性初始化就好了。</p> <h3 id=\"toc_1\">自定义 SubscriptionBehavior</h3> <p>接下来，和上一节创建 <code>CustomSubject</code> 一样，我们也要给 <code>CustomScan</code> 自定义一个 <code>CustomBehavior</code> 对象。因为我们要在接收到上游事件之后，进行累加计算。还是先来看它的定义：</p> <pre class=\"hljs\"><code class=\"swift hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomScan</span>&lt;<span class=\"hljs-title\">Upstream</span>: <span class=\"hljs-title\">Publisher</span>, <span class=\"hljs-title\">Output</span>&gt;: <span class=\"hljs-title\">Publisher</span> </span>{\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Behavior</span>: <span class=\"hljs-title\">SubscriptionBehavior</span> </span>{\n    <span class=\"hljs-keyword\">typealias</span> <span class=\"hljs-type\">Input</span> = <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Output</span>\n    <span class=\"hljs-keyword\">var</span> upstream: <span class=\"hljs-type\">Subscription?</span> = <span class=\"hljs-literal\">nil</span>\n    <span class=\"hljs-keyword\">let</span> downstream: <span class=\"hljs-type\">AnySubscriber</span>&lt;<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Failure</span>&gt;\n    <span class=\"hljs-keyword\">var</span> demand: <span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Demand</span> = .<span class=\"hljs-keyword\">none</span>\n    <span class=\"hljs-keyword\">let</span> reducer: (<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Output</span>) -&gt; <span class=\"hljs-type\">Output</span>\n    <span class=\"hljs-keyword\">var</span> state: <span class=\"hljs-type\">Output</span>\n\n    <span class=\"hljs-keyword\">init</span>(downstream: <span class=\"hljs-type\">AnySubscriber</span>&lt;<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Failure</span>&gt;,\n      reducer: @escaping (<span class=\"hljs-type\">Output</span>, <span class=\"hljs-type\">Upstream</span>.<span class=\"hljs-type\">Output</span>) -&gt; <span class=\"hljs-type\">Output</span>,\n      initialState: <span class=\"hljs-type\">Output</span>) {\n      <span class=\"hljs-keyword\">self</span>.downstream = downstream\n      <span class=\"hljs-keyword\">self</span>.reducer = reducer\n      <span class=\"hljs-keyword\">self</span>.state = initialState\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">receive</span><span class=\"hljs-params\">(<span class=\"hljs-number\">_</span> input: Upstream.Output)</span></span> -&gt; <span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Demand</span> {\n      state = reducer(state, input)\n      <span class=\"hljs-keyword\">return</span> downstream.receive(state)\n    }\n  }\n}\n</code></pre> <p>可以看到，除了“沿袭”自 <code>SubscriptionBehavior</code> 的内容之外，<code>Behavior</code> 还持有了 <code>CustomScan</code> 的计算方法和初始状态，通过这个定义，我们可以进一步领会在 <code>Publisher</code> 背后，<code>Subscription</code> 对象的功能。在我们的实现里，上游事件值的累计，是在递交给订阅者的时候，计算出来的。</p> <h3 id=\"toc_2\">实现 Publisher 约束的方法</h3> <p>有了 <code>Behavior</code> 之后，就可以实现 <code>CustomScan</code> 的剩余方法了。也就是 <code>Publisher</code> 约束的 <code>receive&lt;S&gt;(subscriber:)</code>：</p> <pre class=\"hljs\"><code class=\"swift hljs\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">receive</span>&lt;S&gt;<span class=\"hljs-params\">(subscriber: S)</span></span>\n  <span class=\"hljs-keyword\">where</span> <span class=\"hljs-type\">S</span>: <span class=\"hljs-type\">Subscriber</span>, <span class=\"hljs-type\">Failure</span> == <span class=\"hljs-type\">S</span>.<span class=\"hljs-type\">Failure</span>, <span class=\"hljs-type\">Output</span> == <span class=\"hljs-type\">S</span>.<span class=\"hljs-type\">Input</span> {\n  <span class=\"hljs-keyword\">let</span> downstream = <span class=\"hljs-type\">AnySubscriber</span>(subscriber)\n  <span class=\"hljs-keyword\">let</span> behavior = <span class=\"hljs-type\">Behavior</span>(\n    downstream: downstream, reducer: reducer, initialState: initialState)\n  <span class=\"hljs-keyword\">let</span> subscription = <span class=\"hljs-type\">CustomSubscription</span>(behavior: behavior)\n  upstream.subscribe(subscription)\n}\n</code></pre> <p>这里，和 <code>CustomSubject</code> 唯一不同的就是，我们把包含了 <code>CustomScan</code> 事件转换逻辑的 <code>Subscription</code> 对象作为一个订阅者，订阅的上游事件发布者。每一个中间环节都像这样订阅订阅上游发布者，整个事件链就通过 <code>Subscription</code> 连接起来了。</p> <h2 id=\"toc_3\">通过单元测试验证模型</h2> <p>说到这里，用于验证 Combine 事件发布订阅模型需要的核心组件，就都完成了。<br>\n为了验证这个模型，我们基于之前写过的 <code>testDeferredSubjects</code>，创建一个新的测试用例：</p> <pre class=\"hljs\"><code class=\"swift hljs\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">testCustomSubjects</span><span class=\"hljs-params\">()</span></span> {\n  <span class=\"hljs-keyword\">var</span> subjects = [<span class=\"hljs-type\">CustomSubject</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;]()\n  <span class=\"hljs-keyword\">let</span> deferred = <span class=\"hljs-type\">Deferred</span> { () -&gt; <span class=\"hljs-type\">CustomSubject</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt; <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-type\">CustomSubject</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;()\n    subjects.append(request)\n\n    <span class=\"hljs-keyword\">return</span> request\n  }\n\n  <span class=\"hljs-keyword\">let</span> scanB = <span class=\"hljs-type\">CustomScan</span>(\n    upstream: deferred,\n    initialResult: <span class=\"hljs-number\">10</span>,\n    nextPartialResult: +)\n\n  <span class=\"hljs-keyword\">var</span> receivedC = [<span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Event</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;]()\n  <span class=\"hljs-keyword\">let</span> sinkC = <span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Sink</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;(\n    receiveCompletion: {\n      receivedC.append(.complete($<span class=\"hljs-number\">0</span>))\n    },\n    receiveValue: {\n      receivedC.append(.value($<span class=\"hljs-number\">0</span>))\n    })\n\n  <span class=\"hljs-keyword\">var</span> receivedD = [<span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Event</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;]()\n  <span class=\"hljs-keyword\">let</span> sinkD = <span class=\"hljs-type\">Subscribers</span>.<span class=\"hljs-type\">Sink</span>&lt;<span class=\"hljs-type\">Int</span>, <span class=\"hljs-type\">Never</span>&gt;(\n    receiveCompletion: {\n      receivedD.append(.complete($<span class=\"hljs-number\">0</span>))\n    },\n    receiveValue: {\n      receivedD.append(.value($<span class=\"hljs-number\">0</span>))\n    })\n\n  scanB.subscribe(sinkC)\n  subjects[<span class=\"hljs-number\">0</span>].send(sequence: <span class=\"hljs-number\">1</span>...<span class=\"hljs-number\">2</span>, completion: <span class=\"hljs-literal\">nil</span>)\n\n  scanB.subscribe(sinkD) <span class=\"hljs-comment\">/// `sinkD` does not receive events in `subjects[0]`</span>\n  subjects[<span class=\"hljs-number\">0</span>].send(sequence: <span class=\"hljs-number\">3</span>...<span class=\"hljs-number\">4</span>, completion: .finished)\n  subjects[<span class=\"hljs-number\">1</span>].send(sequence: <span class=\"hljs-number\">1</span>...<span class=\"hljs-number\">4</span>, completion: .finished)\n\n  <span class=\"hljs-type\">XCTAssertEqual</span>(receivedC, [<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">20</span>].asEvents(completion: .finished))\n  <span class=\"hljs-type\">XCTAssertEqual</span>(receivedD, [<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">20</span>].asEvents(completion: .finished))\n}\n</code></pre> <p>这次，我们让 <code>deferred</code> 包含了两个 <code>CustomSubject</code> 对象。其余的部分，和 <code>testDeferredSubjects</code> 是完全相同的，如果一切顺利，测试的结果也应该和使用 <code>PassthroughSubject</code> 是一样的。不过，在开始自行测试之前，先来想个问题：为什么这个测试用例可以验证我们对模型的推测呢？</p> <p>首先，<code>CustomSubject</code> 作为一个 <code>Publisher</code>，我们定义了它的 <code>receive(subscriber:)</code> 方法。但 <code>sinkC</code> 和 <code>sinkD</code> 订阅它的时候，<code>subscribe</code> 方法仍旧是 Combine 提供的，如果订阅之后 <code>receive(subscriber:)</code> 被调用了，就验证了这个方法被调用的时机；</p> <p>其次，在 <code>receive(subscriber:)</code> 的实现里，<code>receive(subscription: Subscriptions.empty)</code> 应该会导致封装着原始订阅者的 <code>Subscription</code> 中的 <code>request</code> 方法被调用，也就是我们在 <code>CustomSubscription</code> 中定义的 <code>request(_ demand:)</code> 方法；</p> <p>最后，<code>CustomSubscription</code> 是一个值类型，这也就意味着在 <code>receive&lt;S&gt;(subscriber:)</code> 方法里，每个订阅者获得的，都是一份属于它自己的 <code>CustomSubscription</code> 对象，因此，<code>sinkC</code> 和 <code>sinkD</code> 订阅到的结果，也应该是独立的；</p> <p>把这些问题想清楚之后，验证是非常简单的，执行一下这个测试用例就好了，如果一切顺利，它应该是可以 Pass 的：</p> <div class=\"row\"><div class=\"col-12\"><img src=\"https://image.boxueio.com/z53-the-hidden-subscription-obj-iii-1@2x.jpg\" alt=\"\"></div></div> <h2 id=\"toc_4\">What's next?</h2> <p>以上，就是对 Combine 基础工作原理方面的研究，现在，对于 Combine 中的事件是如何发送的，如何订阅的，以及 <code>Publisher</code>，<code>Subscriber</code> 和 <code>Subscription</code> 这三个角色在整个模型中的角色，我们应该了解的比较清楚了。</p> <p>接下来，要探索的，是关于“共享”的话题。就像之前在测试用例分析中说到的，每个订阅者独占的 <code>Subscription</code> 对象会导致事件在传递到不同订阅者的时候发生重复计算。但有些时候，我们并不希望如此。如何避免这种问题呢？如何实现类似“一发多收”的效果呢？如何能缓存要下发的事件呢？在 RxSwift 里，我们可以用 <code>ConnectableObservable&lt;E&gt;</code>。那么，在 Combine 里，如何实现类似的“共享”功能呢？</p></div>"
}
